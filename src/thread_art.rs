extern crate bincode;
extern crate cgmath;
extern crate csv;
extern crate gl;
extern crate glutin;
extern crate image;
extern crate rand;
extern crate serde;

use std::collections::HashMap;
use std::collections::hash_map::Entry;
use std::ffi::CString;
use std::fs::{File, OpenOptions};
use std::io::prelude::*;
use std::os::raw::c_void;
use std::path::Path;
use std::time::{Duration, Instant};

use self::cgmath::{Matrix, MetricSpace, Vector2, Vector3, Vector4};
use self::cgmath::prelude::InnerSpace;
use self::csv::Writer;
use self::glutin::GlContext;
use self::image::{GrayImage, RgbImage};
use self::rand::Rng;
use self::serde::{Serialize, Deserialize};

use image_utils::*;
use render::*;
use shader::*;

/// Single action to perform to construct the ThreadArt.
pub struct Instruction {
    /// The index of the thread to move.
    pub thread: usize,

    /// The index of the peg to wrap the thread around.
    pub peg: usize,
}

/// The final thread art generated by the pipeline as a set of instructions.
pub struct ThreadArt {
    /// The instruction which can be performed to construct the thread art.
    pub instructions: Vec<Instruction>,

    /// The final fitness of the the thread art.
    pub fitness: f32,

    // TODO(orglofch): Return a thumbnail of the solution.
}

/// Configuration options for the thread art solver.
pub struct ThreadArtConfig {
    /// The target image to match.
    pub target_img: RgbImage,

    /// The set of peg positions that threads can be wrapped around.
    pub pegs: Vec<Vector2<u32>>,

    /// The `(r, g, b)` threads.
    pub threads: Vec<Vector3<u8>>,

    /// The `(r, g, b)` background colour.
    ///
    /// TODO(orglofch): Support arbitrary textures.
    pub background_colour: Vector3<u8>,

    /// Checkpoint file.
    pub checkpoint_file: String,
    /// How frequently to checkpoint.
    pub checkpoint_frequency: Duration,

    /// Image indicating salient features in the `target_image`.
    pub saliency_map: Option<GrayImage>,

    /// Fitness CSV file.
    pub fitness_csv_file: String,
}

/// Generates thread art for the given `config`.
pub fn run_solver(config: &ThreadArtConfig) -> ThreadArt {
    // Set up window.
    let window =
        glutin::WindowBuilder::new()
        .with_title("Thread Art")
        // Divide by two to counteract retina display.
        // TODO(orglofch): Pull in device information to decide this.
        .with_dimensions(config.target_img.width() / 2, config.target_img.height() / 2);
    let context = glutin::ContextBuilder::new().with_vsync(true);
    let mut events_loop = glutin::EventsLoop::new();
    let gl_window = glutin::GlWindow::new(window, context, &events_loop).unwrap();

    // Set up OpenGL context.
    unsafe {
        gl_window.make_current().unwrap();
        gl::load_with(|symbol| gl_window.get_proc_address(symbol) as *const _);

        gl::Enable(gl::BLEND);
        gl::BlendFunc(gl::SRC_ALPHA, gl::ONE_MINUS_SRC_ALPHA);
        gl::Enable(gl::LINE_SMOOTH);
        gl::Disable(gl::DEPTH_TEST);
        gl::Disable(gl::CULL_FACE);

        // Load shaders.
        let shader = Shader::create("data/shader/vs.vert", "data/shader/fs.frag");
        gl::UseProgram(shader.id);

        // Note: We intentionally swap bottom and top here since the image and
        // OpenGL conventions have inverted y-axis.
        let ortho_mat = cgmath::ortho(
            0.0,
            config.target_img.width() as f32,
            0.0,
            config.target_img.height() as f32,
            -1.0,
            1.0,
        );

        let location =
            gl::GetUniformLocation(shader.id, CString::new("projection").unwrap().as_ptr());
        gl::UniformMatrix4fv(location, 1, false as u8, ortho_mat.as_ptr());
    }

    let mut peg_vao = 0;
    let mut peg_vbo = 0;
    let mut peg_ebo = 0;

    let mut vao = 0;
    let mut vbo = 0;
    let mut ebo = 0;
    let mut fbo = 0;
    let mut rbo = 0;

    let (peg_vertices, peg_indices) = build_peg_index(&config);

    unsafe {
        gl::GenVertexArrays(1, &mut vao);
        gl::GenBuffers(1, &mut vbo);
        gl::GenBuffers(1, &mut ebo);

        gl::GenVertexArrays(1, &mut peg_vao);
        gl::GenBuffers(1, &mut peg_vbo);
        gl::GenBuffers(1, &mut peg_ebo);

        gl::GenRenderbuffers(1, &mut rbo);
        gl::BindRenderbuffer(gl::RENDERBUFFER, rbo);
        gl::RenderbufferStorage(gl::RENDERBUFFER, gl::RGB8, config.target_img.width() as i32, config.target_img.height() as i32);

        gl::GenFramebuffers(1, &mut fbo);
        gl::BindFramebuffer(gl::FRAMEBUFFER, fbo);

        gl::FramebufferRenderbuffer(gl::FRAMEBUFFER, gl::COLOR_ATTACHMENT0, gl::RENDERBUFFER, rbo);

        let status = gl::CheckFramebufferStatus(gl::FRAMEBUFFER);
        if status != gl::FRAMEBUFFER_COMPLETE {
            panic!("Failed to initialize frame buffer");
        }

        gl::BindFramebuffer(gl::FRAMEBUFFER, 0);

        // TODO: Support using an arbitrary texture for the background.
        gl::ClearColor(
            config.background_colour[0] as f32 / 255.0,
            config.background_colour[1] as f32 / 255.0,
            config.background_colour[2] as f32 / 255.0,
            1.0,
        );

        gl::PointSize(2.0);

        buffer_to_gpu(&peg_vertices, &peg_indices, peg_vao, peg_vbo, peg_ebo);
    }

    let mut lines: Vec<Line> = Vec::new();

    // Load lines from the checkpoint if provided and non-empty.
    if !config.checkpoint_file.is_empty() && Path::new(&config.checkpoint_file).exists() {
        let mut file = OpenOptions::new()
            .read(true)
            .open(&config.checkpoint_file)
            .unwrap();

        let mut serialized: Vec<u8> = Vec::new();
        file.read_to_end(&mut serialized).unwrap();

        lines = deserialize(&serialized);

        println!("Load {} lines", lines.len());
    }

    // Precompute potential peg transitions.
    //
    // TODO(orglofch): This is written in the dumbest way possible right now. Use
    // a kd-tree.
    //
    // Allows pegs positions to move some fixed distance from their current position.
    //
    // Reversed (start, end) -> (end, start) patterns are not included so the pegs used
    // in lines should be reversed to calculate the full list.
    let k_max_peg_move_distance = 25.0;
    let mut peg_transitions: HashMap<(usize, usize), Vec<(usize, usize)>> = HashMap::new();
    /*for i in 0..config.pegs.len() {
        let start = config.pegs[i].cast::<f64>().unwrap();
        for j in (i + 1)..config.pegs.len() {
            let end = config.pegs[j].cast::<f64>().unwrap();
            for ii in 0..config.pegs.len() {
                let new_start = config.pegs[ii].cast::<f64>().unwrap();
                if start.distance(new_start) > k_max_peg_move_distance &&
                    end.distance(new_start) > k_max_peg_move_distance
                {
                    continue;
                }

                for jj in (ii + 1)..config.pegs.len() {
                    if (ii == i && jj == j) || (ii == j && jj == i) {
                        continue;
                    }

                    let new_end = config.pegs[jj].cast::<f64>().unwrap();
                    if (start.distance(new_start) <= k_max_peg_move_distance &&
                            end.distance(new_end) <= k_max_peg_move_distance) ||
                        (start.distance(new_end) <= k_max_peg_move_distance &&
                             end.distance(new_start) <= k_max_peg_move_distance)
                    {
                        match peg_transitions.entry((i, j)) {
                            Entry::Vacant(e) => {
                                e.insert(vec![(ii, jj)]);
                            }
                            Entry::Occupied(mut e) => {
                                e.get_mut().push((ii, jj));
                            }
                        }
                    }
                }
            }
        }
    }*/


    let mut previous_cost = 0.0; //std::f64::MAX;

    let mut rng = rand::thread_rng();

    let mut last_checkpoint = Instant::now();


    let mut last_fitness_record_iteration = 0;
    let k_fitness_record_frequency = 100;
    let mut fitness_graph_points: Vec<(u32, f64)> = Vec::new();

    let mut running = true;
    let mut paused = false;
    let mut show_pegs = false;
    let mut paused_i = lines.len();
    let mut temperature = 0.0015;
    let entropy = 0.99995;
    let mut speed = 1;
    let mut iteration = 0_u32;

    let (width, height) = config.target_img.dimensions();
    let mut img_buffer = Raster::new(
        width as usize,
        height as usize,
        vec![0_u8; width as usize * height as usize * 3],
    );

    let mut last_start_time = Instant::now();
    while running {
        events_loop.poll_events(|event| match event {
            glutin::Event::WindowEvent { event, .. } => {
                match event {
                    glutin::WindowEvent::Closed => running = false,
                    glutin::WindowEvent::ReceivedCharacter(input) => {
                        match input {
                            'q' | 'Q' => running = false,
                            'p' | 'P' => {
                                if paused {
                                    paused = false;
                                } else {
                                    paused = true;
                                    paused_i = lines.len() - 1;
                                }
                            }
                            'a' | 'A' => {
                                if paused {
                                    paused_i = std::cmp::max(0, paused_i as i32 - speed as i32) as
                                        usize;
                                }
                                speed += 1;
                            }
                            'd' | 'D' => {
                                if paused {
                                    paused_i = std::cmp::min(lines.len() - 1, paused_i + speed);
                                }
                                speed += 1;
                            }
                            's' | 'S' => {
                                show_pegs = !show_pegs;
                            }
                            _ => {
                                speed = 1;
                            }
                        }
                    }
                    _ => (),
                }
            }
            _ => (),
        });

        // TODO: Don't do this when paused.
        let sample = if !paused {
            sample_new_lines(&config, &lines, &peg_transitions)
        } else {
            lines.to_vec()
        };

        /*let sample = vec![
            Line {
                start_peg: 0,
                end_peg: i % config.pegs.len(),
                thread: 6
            }
        ];*/
        // Build index buffers.
        // TODO: Incrementally update the buffers instead of rebuilding.

        //draw_line(&config.pegs[best_line.start_peg], &config.pegs[best_line.end_peg],
        //&config.threads[best_line.thread], &mut source_img);

        //lines.push(best_line);

        let (thread_vertices, thread_indices) = if paused {
            build_vertex_index(&config, &lines[0..paused_i])
        } else {
            build_vertex_index(&config, &sample)
        };

        unsafe {
            //gl::BindFramebuffer(gl::FRAMEBUFFER, fbo);
            //gl::DrawBuffers(1, &mut fbo);

            gl::Clear(gl::COLOR_BUFFER_BIT);

            buffer_to_gpu(&thread_vertices, &thread_indices, vao, vbo, ebo);

            gl::BindVertexArray(vao);
            gl::DrawElements(
                gl::LINES,
                thread_indices.len() as i32,
                gl::UNSIGNED_INT,
                std::ptr::null(),
            );
            gl::BindVertexArray(0);

            // Read back the rendered state.
            // TODO: Try reading asynchronously from pbo.
            gl::ReadPixels(
                0,
                0,
                config.target_img.width() as i32,
                config.target_img.height() as i32,
                gl::RGB,
                gl::UNSIGNED_BYTE,
                &mut img_buffer.data[0] as *mut u8 as *mut c_void,
            );

            if show_pegs {
                gl::BindVertexArray(peg_vao);
                gl::DrawElements(
                    gl::POINTS,
                    peg_indices.len() as i32,
                    gl::UNSIGNED_INT,
                    std::ptr::null(),
                );
                gl::BindVertexArray(0);
            }

            // TODO: Flip buffer vertically.

            //gl::BindFramebuffer(gl::FRAMEBUFFER, 0);
        }

        // TODO: The concept of cost vs fitness is currently flipped here.
        let mut new_cost = cost(&config, &img_buffer);

        new_cost -= sample.len() as f64 * 0.00001;

        let acceptance_probability = boltzmann_probability(previous_cost, new_cost, temperature); //(new_cost / previous_cost).powf(500.0).min(1.0);

        //println!("Acceptance probability {}", acceptance_probability);

        // TODO: Consolidate all the paused logic.
        if !paused &&
            (new_cost > previous_cost || rng.gen_range(0.0, 1.0) < acceptance_probability)
        {
            lines = sample.to_vec();
            previous_cost = new_cost;
        }

        // TODO: Turn off checkpointing when paused.
        let now = Instant::now();
        if !config.checkpoint_file.is_empty() &&
            now - last_checkpoint > config.checkpoint_frequency
        {
            let mut file = File::create(&config.checkpoint_file).unwrap();

            println!("Cost: {}", previous_cost);
            println!(
                "IPS {:?}",
                iteration / (last_start_time.elapsed().as_secs() + 1) as u32
            );
            println!("Lines {}", lines.len());
            println!("Iterations {}", iteration);
            println!("Temperature {}", temperature);

            let serialized = serialize(&lines);

            let mut pos = 0;
            while pos < serialized.len() {
                let bytes_written = file.write(&serialized[pos..]).unwrap();
                pos += bytes_written;
            }

            println!("Checkpoint {} lines", lines.len());
            last_checkpoint = now;
        }
        if iteration - last_fitness_record_iteration > k_fitness_record_frequency {
            fitness_graph_points.push((iteration, previous_cost));
            last_fitness_record_iteration = iteration;
        }

        gl_window.swap_buffers().unwrap();

        temperature *= entropy;
        iteration += 1;
    }

    if !config.fitness_csv_file.is_empty() {
        let mut csv_writer = Writer::from_path(&config.fitness_csv_file).unwrap();

        for (iteration, fitness) in &fitness_graph_points {
            csv_writer.write_record(&[iteration.to_string(), fitness.to_string()]);
        }

        csv_writer.flush().unwrap();
    }

    unsafe {
        gl::DeleteVertexArrays(1, &vao);
        gl::DeleteBuffers(1, &vbo);
        gl::DeleteBuffers(1, &vbo);
    }

    return ThreadArt {
        instructions: Vec::new(),
        fitness: 0.0,
    };
}


fn boltzmann_probability(current_fitness: f64, new_fitness: f64, temperature: f64) -> f64 {
    let diff = new_fitness - current_fitness;
    return if temperature <= 0.0 {
        0.0
    } else {
        (diff / temperature).exp()
    };
}

/// A single line generated by wrapping a thread from one peg to another.
///
/// Note: Unlike in thread art, a thread can jump from one set of pegs
/// to another without being connected in between. We relax the restriction
/// that a thread must travel from one peg to the next to make the problem
/// easier to solve. Afterwards, we will join all the threads to make it
/// actual thread art.
#[derive(Clone, Debug, Deserialize, Serialize)]
struct Line {
    /// The index of the start peg of the line.
    pub start_peg: usize,

    /// The index of the end peg of the line.
    pub end_peg: usize,

    /// The index of the thread used.
    pub thread: usize,
}

/// Generates instructions for a set of `lines`.
///
/// The lines must be ordered s.t. individual threads are continous
/// (i.e. start_peg of next line = end_peg of last line).
fn generate_instructions(lines: &Vec<Line>) -> Vec<Instruction> {
    let mut instructions = Vec::new();

    let mut last_peg_per_thread: HashMap<usize, usize> = HashMap::new();
    for line in lines {
        let previous_end = last_peg_per_thread.insert(line.thread, line.end_peg);
        match previous_end {
            Some(peg) => {
                assert!(
                    peg == line.start_peg,
                    "Cannot generated instructions, lines are not continous"
                );
                instructions.push(Instruction {
                    thread: line.thread,
                    peg: line.end_peg,
                });
            }
            None => {
                // Place the start position if this is the first instruction for
                // the thread.
                instructions.push(Instruction {
                    thread: line.thread,
                    peg: line.start_peg,
                });
            }

        }
    }

    return instructions;
}

/// Serializes the current state of the solver.
fn serialize(lines: &Vec<Line>) -> Vec<u8> {
    return bincode::serialize(&lines).unwrap();
}

/// Deserializes solver state from a buffer.
fn deserialize(buffer: &Vec<u8>) -> Vec<Line> {
    let lines: Vec<Line> = bincode::deserialize(&buffer[..]).unwrap();
    return lines;
}

/// Returns the cost of the image in the OpenGL backbuffer.
///
/// TODO: Maybe perform the OpenGL stuff here so we can just pass the sample.
/// Probably move this into image utils instead and keep just the penalization
/// term here.
/// TODO: Try different image fitness.
/// TODO: This is really expensive for some reason.
fn cost(config: &ThreadArtConfig, source_img: &Raster<u8>) -> f64 {
    assert_eq!(config.target_img.width() as usize, source_img.width);
    assert_eq!(config.target_img.height() as usize, source_img.height);

    let total_pixels = config.target_img.width() * config.target_img.height();

    let mut total_weight = 0.0;
    let mut error = 0.0;
    for y in 0..config.target_img.height() {
        for x in 0..config.target_img.width() {
            let target_pixel: Vector3<f64> = {
                let pixel = config.target_img.get_pixel(x as u32, y as u32);
                Vector3::from(pixel.data).cast::<f64>().unwrap() / 255.0
            };
            let source_pixel: Vector3<f64> = source_img
                .get(x as usize, y as usize)
                .cast::<f64>()
                .unwrap() / 255.0;

            let weight = match config.saliency_map {
                Some(ref image) => image.get_pixel(x as u32, y as u32)[0] as f64 / 255.0,
                None => 1.0,
            };

            // TODO: Geometric distance between colors doesn't work well for RGBs.
            let distance = target_pixel.distance(source_pixel);
            // TODO: Try L1 norm.
            error += distance * distance * weight;
            total_weight += weight;
        }
    }

    // TODO: Penalize solutions with more lines.
    let mean_error = error / total_weight;

    //let rmse = mean_error.sqrt();

    let psnr = 10.0 * (1.0 / mean_error).log10();

    return psnr;
}

/// Returns an index of peg vertices which can be used to render pegs.
fn build_peg_index(config: &ThreadArtConfig) -> (Vec<Vertex>, Vec<u32>) {
    let mut vertices: Vec<Vertex> = Vec::with_capacity(config.pegs.len());
    let mut indices: Vec<u32> = Vec::with_capacity(config.pegs.len());

    // TODO: Use the inverted background color to ensure we have contrast.
    let colour = Vector4::new(0.0, 0.0, 0.0, 1.0);

    for peg in &config.pegs {
        vertices.push(Vertex::new(peg.cast::<f32>().unwrap(), colour));
        indices.push(vertices.len() as u32 - 1);
    }
    (vertices, indices)
}

/// Returns an index of vertices which can be buffered to the GPU for rendering.
fn build_vertex_index(config: &ThreadArtConfig, lines: &[Line]) -> (Vec<Vertex>, Vec<u32>) {
    let mut vertices: Vec<Vertex> = Vec::with_capacity(lines.len());
    let mut indices: Vec<u32> = Vec::with_capacity(lines.len() * 2);

    // Maps from (peg_index, thread) pairs to vertex indices.
    let mut final_index_by_vertex_info: HashMap<(usize, usize), usize> =
        HashMap::with_capacity(lines.len());
    for line in lines {
        let start = config.pegs[line.start_peg].cast::<f32>().unwrap();
        let end = config.pegs[line.end_peg].cast::<f32>().unwrap();
        let colour = config.threads[line.thread];

        // Dequantize the colour and add alpha.
        let dequantized_colour = Vector4::new(
            colour[0] as f32 / 255.0,
            colour[1] as f32 / 255.0,
            colour[2] as f32 / 255.0,
            1.0,
        );

        // Place the vertex info in tuples since the render struct Vertex uses f32s for rendering.
        let vertex_start_info = (line.start_peg, line.thread);
        let vertex_end_info = (line.end_peg, line.thread);

        let start_index = match final_index_by_vertex_info.entry(vertex_start_info) {
            Entry::Occupied(entry) => *entry.get(),
            Entry::Vacant(entry) => {
                vertices.push(Vertex::new(end, dequantized_colour));
                *entry.insert(vertices.len() - 1)
            }
        };

        let end_index = match final_index_by_vertex_info.entry(vertex_end_info) {
            Entry::Occupied(entry) => *entry.get(),
            Entry::Vacant(entry) => {
                vertices.push(Vertex::new(start, dequantized_colour));
                *entry.insert(vertices.len() - 1)
            }
        };

        indices.push(start_index as u32);
        indices.push(end_index as u32);
    }
    (vertices, indices)
}

/// Returns a new sample of lines by perturbing an input set of `lines`.
///
/// There are two possible perturbations:
/// 1) - Adding a new line.
/// 2) - Removing an old line.
fn sample_new_lines(
    config: &ThreadArtConfig,
    lines: &Vec<Line>,
    peg_transitions: &HashMap<(usize, usize), Vec<(usize, usize)>>,
) -> Vec<Line> {
    let mut rng = rand::thread_rng();

    let mut sample: Vec<Line> = lines.to_vec();

    let k_min_lines = 20;

    let action_prob: f32 = rng.gen();
    // TODO: Make probability a config param.
    if action_prob < 0.3 {
        // Insert a new line.
        let position = rng.gen_range(0, lines.len() + 1);
        let thread = rng.gen_range(0, config.threads.len());
        let start_peg = rng.gen_range(0, config.pegs.len());
        let mut end_peg = rng.gen_range(0, config.pegs.len() - 1);
        if end_peg == start_peg {
            end_peg += 1;
        }
        sample.insert(
            position,
            Line {
                start_peg: start_peg,
                end_peg: end_peg,
                thread: thread,
            },
        );
    } else if action_prob < 0.5 && lines.len() > 0 {
        // Modify the thread of a line.
        let position = rng.gen_range(0, lines.len());
        let mut thread = rng.gen_range(0, config.threads.len() - 1);
        if thread == sample[position].thread {
            thread += 1;
        }
        sample[position].thread = thread;
    } else if action_prob < 0.65 && lines.len() > 0 {
        // Modify the start position of a line.
        let position = rng.gen_range(0, lines.len());
        let mut peg = rng.gen_range(0, config.pegs.len() - 1);
        if peg == sample[position].start_peg {
            peg += 1;
        }
        sample[position].start_peg = peg;
    } else if action_prob < 0.8 && lines.len() > 0 {
        // Modify the end position of a line.
        let position = rng.gen_range(0, lines.len());
        let mut peg = rng.gen_range(0, config.pegs.len() - 1);
        if peg == sample[position].end_peg {
            peg += 1;
        }
        sample[position].end_peg = peg;
    /*} else if action_prob < 0.8 && lines.len() > 0 {
        // Move an existing line.
        let position = rng.gen_range(0, lines.len());
        let start = sample[position].start_peg;
        let end = sample[position].end_peg;

        let empty = Vec::new();
        let start_end_transitions = &peg_transitions.get(&(start, end)).unwrap_or(&empty);
        let end_start_transitions = &peg_transitions.get(&(end, start)).unwrap_or(&empty);
        if !start_end_transitions.is_empty() || !end_start_transitions.is_empty() {
            let transition =
                rng.gen_range(0, start_end_transitions.len() + end_start_transitions.len());
            if transition < start_end_transitions.len() {
                sample[position].start_peg = start_end_transitions[transition].0;
                sample[position].end_peg = start_end_transitions[transition].1;
            } else {
                sample[position].start_peg = end_start_transitions[transition].0;
                sample[position].end_peg = end_start_transitions[transition].1;
            }
        }*/
    } else if lines.len() > k_min_lines {
        // Delete an existing line.
        let position = rng.gen_range(0, lines.len());
        sample.remove(position);
    }
    return sample;
}

/// Finds the "best" line between a set of pegs.
///
/// The best line is the line which removes the most error between
/// the current image and the source image. If there is no best
/// line, None is returned.
fn find_best_line(
    config: &ThreadArtConfig,
    lines: &Vec<Line>,
    source_img: &RgbImage,
) -> Option<Line> {
    // TODO: Make this a param.
    //const THREADS: usize = 32;
    //let threads: Vec<_> = (0..THREADS).map(|_| thread::spawn(|| Stats(4))).collect();
    let mut best_fitness = std::f64::MIN;
    let mut best_thread = None;
    for s in 0..config.pegs.len() {
        let peg_1 = config.pegs[s];
        // Connect the first peg to all subsequence pegs.
        for e in (s + 1)..config.pegs.len() {
            for t in 0..config.threads.len() {
                let peg_2 = config.pegs[e];

                if peg_1 == peg_2 {
                    continue;
                }

                let length = (peg_1.cast::<f64>().unwrap() - peg_2.cast::<f64>().unwrap())
                    .magnitude();

                let fitness = line_fitness(
                    &config.target_img,
                    &source_img,
                    &peg_1,
                    &peg_2,
                    &config.threads[t],
                ); // / length;

                if fitness > best_fitness {
                    best_thread = Some(Line {
                        start_peg: s,
                        end_peg: e,
                        thread: t,
                    });
                    best_fitness = fitness;
                }
            }
        }
    }
    return best_thread;
}
